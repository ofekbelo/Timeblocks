# Sub-Agent 2.1: Database & Prisma Setup

**Parent:** Agent 2 - Backend Foundation  
**Status:** Ready to Execute  
**Dependencies:** Agent 1 (Project Setup), PostgreSQL installed  
**Estimated Time:** 2-3 hours  
**Working Directory:** `timeblocks/apps/server/`

---

## ğŸ“‹ Mission

Set up NestJS with Prisma ORM and PostgreSQL, create the complete database schema, and prepare the foundation for the backend API.

---

## ğŸ¯ What You'll Build

1. **NestJS Project** - Complete backend structure
2. **Prisma ORM** - Database access layer
3. **PostgreSQL Schema** - All models and relationships
4. **Migrations** - Database version control
5. **Prisma Service** - Reusable database service

---

## âœ… Step-by-Step Tasks

### TASK 1: Initialize NestJS Project

Navigate to the server directory and initialize:

```bash
cd apps/server
pnpm init
```

---

### TASK 2: Install Dependencies

Install all required packages:

```bash
# NestJS Core
pnpm add @nestjs/common@^10.0.0 @nestjs/core@^10.0.0 @nestjs/platform-express@^10.0.0
pnpm add reflect-metadata@^0.1.13 rxjs@^7.8.0

# Prisma
pnpm add @prisma/client@^5.7.0

# Configuration
pnpm add @nestjs/config@^3.1.0

# Validation
pnpm add zod@^3.22.0 class-validator@^0.14.0 class-transformer@^0.5.1

# Dev Dependencies
pnpm add -D @nestjs/cli@^10.0.0 @nestjs/schematics@^10.0.0
pnpm add -D typescript@^5.3.0 @types/node@^22.0.0
pnpm add -D ts-node@^10.9.0 tsconfig-paths@^4.2.0
pnpm add -D prisma@^5.7.0
pnpm add -D eslint-config-custom@workspace:*
```

---

### TASK 3: Create package.json

Create `apps/server/package.json`:

```json
{
  "name": "@timeblocks/server",
  "version": "1.0.0",
  "private": true,
  "description": "TimeBlocks Backend API",
  "scripts": {
    "build": "nest build",
    "dev": "nest start --watch",
    "start": "node dist/main",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,test}/**/*.ts\" --fix",
    "typecheck": "tsc --noEmit",
    "test": "echo \"Tests will be added by Agent 8\"",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio",
    "prisma:seed": "ts-node prisma/seed.ts",
    "clean": "rm -rf dist node_modules .turbo"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/config": "^3.1.0",
    "@prisma/client": "^5.7.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.0",
    "zod": "^3.22.0",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@types/node": "^22.0.0",
    "typescript": "^5.3.0",
    "ts-node": "^10.9.0",
    "tsconfig-paths": "^4.2.0",
    "prisma": "^5.7.0",
    "eslint-config-custom": "workspace:*"
  }
}
```

---

### TASK 4: NestJS Configuration Files

Create `apps/server/nest-cli.json`:

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "webpack": false
  }
}
```

Create `apps/server/tsconfig.json`:

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test"]
}
```

Create `apps/server/.eslintrc.js`:

```javascript
module.exports = {
  extends: ['eslint-config-custom'],
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};
```

---

### TASK 5: Initialize Prisma

```bash
cd apps/server
npx prisma init
```

This creates:

- `prisma/schema.prisma`
- `.env` file

---

### TASK 6: Create Complete Prisma Schema

Replace the content of `apps/server/prisma/schema.prisma`:

```prisma
// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// USER MODEL
// ==========================================
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String   @map("password_hash")
  fullName      String   @map("full_name")
  avatarUrl     String?  @map("avatar_url")

  // Settings
  timezone      String   @default("Asia/Jerusalem")
  currency      String   @default("ILS")
  preferences   Json?

  // Email verification
  emailVerified Boolean  @default(false) @map("email_verified")

  // Timestamps
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  clients       Client[]
  projects      Project[]
  timeEntries   TimeEntry[]
  refreshTokens RefreshToken[]

  @@map("users")
}

// ==========================================
// CLIENT MODEL
// ==========================================
model Client {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")

  // Client info
  name       String
  email      String?
  phone      String?
  address    String?  @db.Text
  color      String   @default("#4A90E2")
  notes      String?  @db.Text

  // Status
  isArchived Boolean  @default(false) @map("is_archived")

  // Timestamps
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  projects   Project[]

  @@index([userId])
  @@map("clients")
}

// ==========================================
// PROJECT MODEL
// ==========================================
model Project {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  clientId        String?   @map("client_id")

  // Project info
  name            String
  hourlyRate      Decimal?  @map("hourly_rate") @db.Decimal(10, 2)
  estimatedBudget Decimal?  @map("estimated_budget") @db.Decimal(10, 2)
  startDate       DateTime? @map("start_date")
  endDate         DateTime? @map("end_date")

  // Status and appearance
  status          ProjectStatus @default(ACTIVE)
  color           String        @default("#4A90E2")
  isArchived      Boolean       @default(false) @map("is_archived")

  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  client          Client?   @relation(fields: [clientId], references: [id], onDelete: SetNull)
  timeEntries     TimeEntry[]

  @@index([userId])
  @@index([clientId])
  @@index([status])
  @@map("projects")
}

enum ProjectStatus {
  ACTIVE
  ON_HOLD
  COMPLETED
  ARCHIVED
}

// ==========================================
// TIME ENTRY MODEL
// ==========================================
model TimeEntry {
  id          String    @id @default(cuid())
  userId      String    @map("user_id")
  projectId   String    @map("project_id")

  // Entry details
  description String?   @db.Text
  startTime   DateTime  @map("start_time")
  endTime     DateTime? @map("end_time")
  duration    Int?      // Duration in seconds (calculated)

  // Metadata
  isManual    Boolean   @default(false) @map("is_manual")
  tags        String[]  @default([])

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([projectId])
  @@index([startTime])
  @@map("time_entries")
}

// ==========================================
// REFRESH TOKEN MODEL
// ==========================================
model RefreshToken {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")

  // Token info
  token     String   @unique @db.VarChar(500)
  expiresAt DateTime @map("expires_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}
```

---

### TASK 7: Create Environment Files

Create `apps/server/.env`:

```env
# Database
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/timeblocks?schema=public"

# JWT Secrets (generate random strings)
JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"
JWT_REFRESH_SECRET="your-super-secret-refresh-key-change-this-too"

# Email (will be set up later)
RESEND_API_KEY=""

# Frontend URL (for email links)
FRONTEND_URL="http://localhost:5173"

# Server
PORT=3000
NODE_ENV=development
```

Create `apps/server/.env.example`:

```env
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/timeblocks?schema=public"

# JWT Secrets (use strong random strings)
JWT_SECRET="your-jwt-secret-here"
JWT_REFRESH_SECRET="your-refresh-secret-here"

# Email
RESEND_API_KEY="your-resend-api-key"

# Frontend URL
FRONTEND_URL="http://localhost:5173"

# Server
PORT=3000
NODE_ENV=development
```

**Important:** Update the `DATABASE_URL` with your actual PostgreSQL credentials!

---

### TASK 8: Create Database Migration

Generate the initial migration:

```bash
cd apps/server
npx prisma migrate dev --name init
```

This will:

1. Create the database if it doesn't exist
2. Generate SQL migration file
3. Apply migration to database
4. Generate Prisma Client

**Expected output:**

```
âœ” Generated Prisma Client
âœ” Applied migration 20240213_init
```

---

### TASK 9: Create Prisma Module

Create `apps/server/src/prisma/prisma.service.ts`:

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    super({
      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
    console.log('âœ… Database connected');
  }

  async onModuleDestroy() {
    await this.$disconnect();
    console.log('ğŸ”Œ Database disconnected');
  }

  // Helper method for cleaning up in tests
  async cleanDatabase() {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('Cannot clean database in production!');
    }

    const models = Reflect.ownKeys(this).filter((key) => key[0] !== '_');

    return Promise.all(models.map((modelKey) => this[modelKey].deleteMany()));
  }
}
```

Create `apps/server/src/prisma/prisma.module.ts`:

```typescript
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

---

### TASK 10: Create Main Application Files

Create `apps/server/src/main.ts`:

```typescript
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const configService = app.get(ConfigService);
  const port = configService.get('PORT') || 3000;

  // Enable CORS
  app.enableCors({
    origin: [
      'http://localhost:5173', // Vite dev server
      'http://localhost:3001', // React Native
      configService.get('FRONTEND_URL'),
    ].filter(Boolean),
    credentials: true,
  });

  // Global prefix
  app.setGlobalPrefix('api');

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    })
  );

  await app.listen(port);

  console.log(`
    ğŸš€ Server running on: http://localhost:${port}
    ğŸ“š API Documentation: http://localhost:${port}/api/docs
    ğŸ—„ï¸  Database: Connected to PostgreSQL
  `);
}

bootstrap();
```

Create `apps/server/src/app.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from './prisma/prisma.module';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    PrismaModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

Create `apps/server/src/app.controller.ts`:

```typescript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('health')
  getHealth() {
    return this.appService.getHealth();
  }
}
```

Create `apps/server/src/app.service.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma/prisma.service';

@Injectable()
export class AppService {
  constructor(private prisma: PrismaService) {}

  async getHealth() {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return {
        status: 'ok',
        timestamp: new Date().toISOString(),
        database: 'connected',
      };
    } catch (error) {
      return {
        status: 'error',
        timestamp: new Date().toISOString(),
        database: 'disconnected',
        error: error.message,
      };
    }
  }
}
```

---

### TASK 11: Create Seed File (Optional)

Create `apps/server/prisma/seed.ts`:

```typescript
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Seeding database...');

  // Create test user
  const hashedPassword = await bcrypt.hash('Password123!', 12);

  const user = await prisma.user.upsert({
    where: { email: 'test@example.com' },
    update: {},
    create: {
      email: 'test@example.com',
      passwordHash: hashedPassword,
      fullName: 'Test User',
      emailVerified: true,
    },
  });

  console.log('âœ… Created test user:', user.email);

  // Create test client
  const client = await prisma.client.create({
    data: {
      userId: user.id,
      name: 'Acme Corporation',
      email: 'contact@acme.com',
      color: '#4A90E2',
    },
  });

  console.log('âœ… Created test client:', client.name);

  // Create test project
  const project = await prisma.project.create({
    data: {
      userId: user.id,
      clientId: client.id,
      name: 'Website Redesign',
      hourlyRate: 100,
      status: 'ACTIVE',
      color: '#7ED321',
    },
  });

  console.log('âœ… Created test project:', project.name);

  console.log('ğŸ‰ Seeding completed!');
}

main()
  .catch((e) => {
    console.error('âŒ Seeding failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

### TASK 12: Update .gitignore

Make sure `apps/server/.gitignore` includes:

```
# Environment
.env

# Build
dist/
node_modules/

# Prisma
prisma/migrations/**/migration.sql
```

---

### TASK 13: Generate Prisma Client

```bash
cd apps/server
pnpm prisma:generate
```

---

### TASK 14: Start the Server

```bash
cd apps/server
pnpm dev
```

**Expected output:**

```
âœ… Database connected
ğŸš€ Server running on: http://localhost:3000
ğŸ“š API Documentation: http://localhost:3000/api/docs
ğŸ—„ï¸  Database: Connected to PostgreSQL
```

---

## âœ… Verification

Test that everything works:

### 1. Check Health Endpoint

```bash
curl http://localhost:3000/api/health
```

**Expected response:**

```json
{
  "status": "ok",
  "timestamp": "2024-02-13T...",
  "database": "connected"
}
```

### 2. Open Prisma Studio

In a new terminal:

```bash
cd apps/server
pnpm prisma:studio
```

Opens at http://localhost:5555

### 3. Check Database Tables

In Prisma Studio, you should see:

- users
- clients
- projects
- time_entries
- refresh_tokens

### 4. Run Seed (Optional)

```bash
cd apps/server
pnpm prisma:seed
```

---

## âœ… Success Criteria

- [ ] NestJS project structure created
- [ ] All dependencies installed
- [ ] Prisma schema defined with all models
- [ ] Database migration created and applied
- [ ] Prisma Client generated
- [ ] PrismaService and PrismaModule created
- [ ] Main application files created
- [ ] Server starts without errors
- [ ] Health endpoint responds
- [ ] Prisma Studio opens and shows tables
- [ ] PostgreSQL connection works

---

## ğŸ“Š What We Built

```
âœ… NestJS Application Structure
âœ… Prisma ORM with PostgreSQL
âœ… 5 Database Models:
   - User
   - Client
   - Project
   - TimeEntry
   - RefreshToken
âœ… Database Migrations
âœ… Global Prisma Service
âœ… Health Check Endpoint
âœ… Development Environment Ready
```

---

## â¡ï¸ Next Steps

Now that the database layer is complete:

1. âœ… Verify all checks pass
2. ğŸ”’ Continue to **Sub-Agent 2.2: Authentication**
3. Then **Sub-Agent 2.3: API Modules**

---

## ğŸ› Troubleshooting

### "Cannot connect to database"

```bash
# Check PostgreSQL is running
pg_isready

# Check DATABASE_URL in .env
cat apps/server/.env
```

### "Module not found"

```bash
cd apps/server
rm -rf node_modules
pnpm install
```

### "Prisma Client not generated"

```bash
cd apps/server
pnpm prisma:generate
```

### "Port 3000 already in use"

```bash
# Change PORT in .env
echo "PORT=3001" >> apps/server/.env
```

---

**Database setup complete! ğŸ˜ Ready for authentication! ğŸ”**
